## 📌 인사이트 요약

- **배열**은 내부 구조와 메서드의 시간 복잡도를 이해하는 것이 매우 중요
- 반복적 조작에는 `splice()`보다 **스택 방식**이 유리👀
	- 배열 인덱스 접근이 O(1)인 이유는 **엔진 최적화 덕분**
- 불필요한 문자열 조작은 지양 <br>→ **한 번 순회하는 구조로 최적화**🔥
---

# 햄버거 쌓기

## 문제 요약

> 주어진 재료 배열에서 [1, 2, 3, 1] 순서의 **햄버거 패턴**이 완성되면 제거하고,<br>총 완성된 햄버거 개수를 반환

## 트러블 슈팅

```javascript
let match = ingredient.join('').match(/1231/);
let count = 0;

while (match) {
  ingredient.splice(match.index, 4);
  count++;
  match = ingredient.join('').match(/1231/);
}
```

- 위 코드에서 가장 비싼 연산은 바로 `join + match`

> `ingredient.join('')`는 매번 배열 전체를 문자열로 바꾸고,<br>`match()`는 전체 문자열을 대상으로 정규표현식 매칭
> `splice()`는 요소 제거 시마다 **재정렬**까지 발생🤯 

→ 전체적으로 **O(N²)** 이상 소요 → **시간 초과🧨**

## 개선 과정

- 배열 인덱스와 스택 자료 구조를 이용해 한 번만 순회하기<br>→ **O(N)으로 개선**

```javascript
  if (
    stack[len - 4] === 1 &&
    stack[len - 3] === 2 &&
    stack[len - 2] === 3 &&
    stack[len - 1] === 1
  ) {
    stack.pop();
    stack.pop();
    stack.pop();
    stack.pop();
    count++;
  }
}
```

- `peek` 방식으로 마지막 4개만 비교
- **정규식/문자열 처리/재정렬** 모두 제거<br>→ 시간복잡도는 **O(N)** 

### 👀 JS 배열은 연속되지 않았는데 O(N)인가요?

- JS의 `Array`는 C와 같은 언어처럼 **연속된 메모리 구조**가 아니다.
> 내부적으로 숫자 인덱스를 `key`로 가지는 **객체(Object)**

```javascript
const arr = [10, 20, 30];
// 내부 {0: 10, 1: 20, 2: 30, length: 3}
```

#### 그런데 왜 인덱스 접근이 O(1)일까?

>자바스크립트 엔진(예: V8)이 내부적으로 **최적화 처리**<br>→ 정수형 인덱스에 대해서 **진짜 배열처럼 빠르게 동작**

##### ⚠️ 예외 상황
- 희소 배열 → `arr[1000000] = 1`
- 중간 삭제 → `delete arr[2]`
- 문자열 키나 비정상적인 인덱싱

>최적화 해제 → 느려짐

##### 요약

- `배열[index]`는 단순해 보여도 내부적으로는 많은 최적화가 숨어있음
- 가능하면 **정수형 인덱스를 순차적으로 사용**    

### 👀 `pop`이 `splice`보다 훨씬 빠른가요?

>`pop()`은 O(1)이고<br>`splice()`는 O(N)이다.

#### `pop()`
- 배열의 **가장 끝 요소 하나** 제거
- 내부적으로 **재정렬 필요 없음** <br>→ 스택처럼 동작해 시간 복잡도는 O(1)
#### `splice()`

```javascript
arr.splice(-4, 4);
```
- 배열의 **끝에서 4개 삭제**
- 하지만 splice는...

>배열을 **쪼개고, 붙이고, 밀고, 땅기는** 복합 연산
>내부적으로 **새로운 배열 구조**를 만들고 뒤의 요소를 **앞으로 땡긴다**

따라서 `splice()`는 최악의 경우 시간 복잡도 O(N)의 성능을 갖는다.

#### 요약

| 메서드             | 역할          | 시간복잡도       | 특징               |
| --------------- | ----------- | ----------- | ---------------- |
| `pop()`         | 끝 요소 1개 제거  | O(1)        | 스택처럼 동작          |
| `splice(-4, 4)` | 끝에서 4개 제거   | O(N)        | 요소 재정렬 포함        |
| `slice(-4)`     | 끝 4개 **복사** | O(4) = O(1) | 단순 복사<br>→ 읽기 용도 |

## 📌 배운 점

- 배열을 스택처럼 사용할 때는 `push`, `pop`, `slice(-N)`을 적절히 사용
- 불필요한 `join`, `match`, `splice`는 성능 병목이 될 수 있음
- **배열을 하나씩 순회하며, 최근 요소들만 검사하는 구조**로 바꾸는 것이 효과적


>반복 구조에서는 **최대한 pop/push로 설계**

---

# 크레인 인형뽑기

## 문제 요약

> 2차원 배열 형태의 인형판에서 크레인을 이동시키며 인형을 뽑고,  
> 같은 인형이 연속으로 쌓이면 제거 → 총 제거된 인형 개수 반환

## 트러블 슈팅

```javascript
const target = board[row][col];
// 초기화를 안 했다🥲
```

- 뽑은 인형을 **보드에서 제거하지 않음**
    → 다음 턴에서도 같은 인형이 계속 뽑히는 현상 발생


## 개선 과정

```javascript
const target = board[row][col];
board[row][col] = 0; // 초기화에 신경쓰자!!
```

- 뽑은 인형은 **사용 즉시 제거** → **상태 갱신**이 매우 중요
- 동작은 맞는데 계속 **정답이 틀려서** 멘붕에 빠졌다...🤦‍♀️🤦‍♀️

## 배운 점

>배열이나 보드와 같이 **상태가 변화하는 문제**에서는,  
→ 값을 읽은 후의 *상태 갱신* 여부를 반드시 확인할 것

>특히 `pop()` 같은 거 쓸 때 유의하자👊🏻👊🏻


## 📌 핵심

>JS 배열은 진짜 배열이 아니지만, <br>엔진이 **진짜 배열처럼** 동작하게 최적화해준다.
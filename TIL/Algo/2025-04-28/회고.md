`Today I Learned` 그리디 알고리즘 기초 다지기

- [x] 그리디 알고리즘의 기초를 학습했는가?
- [x] [체육복](https://school.programmers.co.kr/learn/courses/30/lessons/42862) 문제를 그리디로 풀이할 수 있는가?
- [x] `indexOf`와 `findIndex` 차이를 이해하고 적절한 상황에 사용할 수 있는가?
- [x] 그리디 문제를 `Set`과 `Map`을 통해 적절한 자료구조로 접근할 수 있는가?---

## 오늘의 배운 점 #TIL

### 1. 그리디 알고리즘이란?

- **항상 가장 좋아 보이는 선택**을 반복하여 최적해를 찾는 알고리즘
- 대개 **정렬 후 조건 체크**를 동반한다✅

### 2. 체육복 문제 핵심 포인트

- [x] `도난`과 `여벌`의 **중복 제거**
- [x] 앞뒤 번호 비교
- [x] `탐색 최적화` 필요

### 3. `indexOf` vs `findIndex`

|함수명|사용 목적|체육복 문제에서 예시|
|---|---|---|
|`indexOf`|특정 **값** 탐색|`arr.indexOf(3)`|
|`findIndex`|특정 **조건** 만족 인덱스 탐색|`arr.findIndex(v => Math.abs(v - 3) === 1)`|

> **조건식이 필요한 경우엔 `findIndex` 를 사용한다📌

### 4.  `Set` vs `Map` 

| 비교 항목      | Set                               | Map                         |
| ---------- | --------------------------------- | --------------------------- |
| 목적         | **중복 없는 값의 존재 여부** 체크             | **키-값 상태 추적**에 유리           |
| 구조         | 값만 저장 <br>`set.has(val)`          | 키-값 쌍 저장 <br>`map.get(key)` |
| 탐색 성능      | `O(1)` <br>`빠름`                   | `O(1)` <br>`상태관리`까지 가능      |
| 활용 예시      | `도난/여벌 존재 여부`                     | `학생 번호 → 체육복 보유 여부` 관리      |
| 체육복 문제 적합성 | **조건 탐색 단순**할 때 적절 <br>`앞뒤 번호 체크` | 복잡한 상태 관리 필요 시 적절           |
## ⚙️ 구현 코드

### 1. 기존 방식 

```javascript
for (let lostStudent of lost) {
  const idx = reserve.findIndex(r => Math.abs(r - lostStudent) === 1);
  if (idx !== -1) {
    reserve.splice(idx, 1);
    // 대여 처리
  }
}
```
### 2. Set 방식 
#성능 #최적화

```javascript
const reserveSet = new Set(reserve);
const lostSet = new Set(lost);

// 중복 제거
for (let student of lost) {
  if (reserveSet.has(student)) {
    reserveSet.delete(student);
    lostSet.delete(student);
  }
}

// 앞뒤 체크
for (let student of lostSet) {
  if (reserveSet.has(student - 1)) {
    reserveSet.delete(student - 1);
  } else if (reserveSet.has(student + 1)) {
    reserveSet.delete(student + 1);
  } else {
    n--; // 체육복 없음
  }
}
```

> 포함 여부만 판단하고 싶다면 `Set` 자료 구조의 `has()` 메서드로,
> 개별 상태 추적이 필요하면 `Map` 자료 구조의 `get() / set()` 메서드로🔥🔥🔥

| 빠른 포함 여부 판단 <br>`O(1)`        | `Set` | `Set.has()` <br>→ 빠름               |
| ----------------------------- | ----- | ---------------------------------- |
| 개별 상태 추적 <br>`도난 여부, 대여 여부` 등 | `Map` | `Map.get()/set()` <br>→ 복잡한 조건 분기용 |

| - 포함 여부만 판단하고 싶을 때<br>- 반복적인 삽입/삭제가 많을 때 | `Set` | - `has()` 메서드로 빠르게 체크 가능<br>- `add()`/`delete()` 성능이 좋음 |
| ---------------------------------------- | ----- | ------------------------------------------------------- |
| 개별 학생의 상태를 관리할 때                         | `Map` | 키 기반으로 세부 상태 추적 가능                                      |

## 🧘 깨달은 점

- 그리디 알고리즘은 기본적으로 `정렬 + 조건 판단 + 효율 탐색`이 핵심이다.
- 효율적으로 탐색하려면 **자료구조의 선택**이 굉장히 중요하다

> 조건 탐색이 단순할수록 `Set`이 짱이다🙌
> 값 포함 확인엔 `Set.has()`가 깡패다.
> 
> 복잡한 상태 추적이 필요하면 `Map`을 사용한다
    
- 체육복 문제처럼 **조건 기반 탐색**엔 `findIndex`를 사용한다.
- 불필요한 `includes`, `splice` 대신 **조건 기반 탐색** 구조로 가는 것이 최적화로 이어지는 지름길🐕🐾🐾

## 자가 점검

- [x]  중복 제거를 구현했는가?
- [x]  탐색에서 조건 비교가 필요한 상황엔 어떤 함수가 필요한가?
- [x] `Set`, `Map`을 언제 선택해야 하는가?

> 내일은 이분탐색을 배우며 `탐색 최적화 전략을 더 넓게` 확장하자💪🏻💪🏻
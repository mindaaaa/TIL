
`Today I Learned` DP의 기본 개념과 *흐름* 정리

- [x] 동적 계획법 (DP)
- [x] 메모이제이션 vs 타뷸레이션
- [x] 피보나치 수열
- [x] 오버플로우 / MOD 연산
## 오늘의 배운 점 #TIL

> **메모이제이션과 동적 계획법은 '선택지'가 아닌 포함 관계!**  

-  DP의 한 방식으로 메모이제이션이 존재한다는 걸 이번에 처음 알게 됐고,  
  이전까지는 '둘 중 어떤 걸 써야 하나?' 고민했던 사고방식이 정리 됐다.

  약간 부끄러웠지만 지금 알았으니 되었다😂

> **피보나치 수를 기준으로 DP의 흐름을 따라가며**  

- 메모이제이션 → 타뷸레이션으로 이어지는 호출 순서를 익히다 보니  
  `왜 타뷸레이션이 더 효율적인지` 체감되었다.

> 함수 호출은 생각보다 **⚠️훨씬 무겁다⚠️**

- 특히 재귀 호출은 `콜스택, 함수 실행, 메모리 등` 시스템에 부담이 크기 때문에  
  단순 for문을 돌며 *Bottom-Up*으로 접근하는 타뷸레이션이 **성능상 훨씬 우수하다는 사실**을 처음 알았다👀  
  알고리즘이 점점 시스템 사고로 확장되는 기분이 들었달까..? 🔥🔥

> [피보나치 수](https://school.programmers.co.kr/learn/courses/30/lessons/12945?itm_content=course14743) 문제를 풀면서

- 정답이라고 확신했던 코드가 다수의 테스트케이스에서 실패했을 때 멘붕💥...  
- 그런데 알고보니 이건 단순한 코드 오류가 아니라 **숫자의 정확도(오버플로우)** 때문이었다는 걸 깨달았다.

```javascript
// 이 코드가 왜 틀릴까?
return fib(n);
```

- JS의 `Number`는 `2^53` 이상이면 정확도가 깨진다.  
    그래서 문제에 주어진 `1234567`로 **mod 연산**을 해야 했던 것!  
    전공 수업에서 *오버플로우 조심하자*란 가르침을 들었지만,  
    이걸 진짜 체감한 건 이번이 처음이었다.
```javascript
for(let i=2; i<=n; i++){
	dp[i] = (dp[i-1] + dp[i-2]) % 1234567;
}
```

## 🧘  깨달은 점

- DP는 단순 암기가 아닌 **패턴 감각**이 중요하다. 
> 각 방식이 **언제 더 나은지 판단할 수 있어야** 한다.

- 성능 최적화를 위해 **mod 연산, overflow 방지**는 필수!
> 계산값을 구하면서 mode 처리를 해야 한다.
    
- 생각보다 실전 코딩은 구현보다 조건 읽기가 더 어렵다.  
> **문제를 꼼꼼하게 읽자...!** 🙏

## ⚙️ 구현 코드
```javascript
function solution(n) {
    function fib(n){
        const dp = [0, 1];
        
        for(let i=2; i<=n; i++){
            dp[i] = (dp[i-1] + dp[i-2]) % 1234567;
        }
        
        return dp[n];
    }
    
    return fib(n);
}
```
## 🎯 내일의 목표

- 계단 오르기, 타일링 문제를 통해 **점화식 훈련**
- 다양한 유형의 점화식을 **직접 손코딩**
- **멀리 뛰기 문제 실전 풀이**로 점화식 감각 완성하기
    
> 오늘은 DP의 개념과 효율성을 실제로 느껴본 하루!  
> 내일은 직접 문제를 풀며 **점화식을 몸에 익혀보자🔥**
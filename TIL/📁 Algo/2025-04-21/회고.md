`Today I Learned` LCS 최장 공통 부분 수열

- [x] LCS 점화식 유도 및 코드 흐름을 이해했는가?
- [x] 바텀업 방식의 LCS 복원 구현이 가능한가?
- [x] 2차원 DP 테이블의 의미와 패딩 처리를 이해했는가?
- [x] LCS의 탑다운과 바텀업 방식을 비교할 수 있는가?
- [x] LIS와 LCS의 개념 차이를 정리했는가?

## 오늘의 배운 점 #TIL

### 1 LCS 점화식 흐름을 손코딩으로 이해

- 2차원 배열 기반의 LCS를 이해하는 데 어려움이 있었지만, <br>**한두 번 직접 손코딩을 통해 2차원 DP 테이블을 채워보니 점화식의 흐름이 눈에 들어오기 시작**했다.

> `dp[i][j] = dp[i - 1][j - 1] + 1`  
> → A[i-1] === B[j-1]일 때 대각선 ↖️
>  
> `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`  
> → 아니면 위👆나 왼쪽👈🏻 중 큰 값 가져오기

### 2 첫 행/열은 0으로 패딩

- 초기에는 `dp[0][j]`, `dp[i][0]` 값이 의미를 이해하지 못했는데<br>**공통 부분 수열을 계산할 때 문자열의 시작점을 안전하게 다루기 위한 `패딩` 역할**임을 알게 됐다.
```javascript
undefined + 1; // NaN
0 + 1; // 1
```

> 실제 코테에서도 **초기값을 0으로 패딩하여 예외처리를 줄이는 기법이 많이 쓰인다**

### 3 LCS DP 테이블 구조 & 방향

|   | "" | A | C | A | Y | K | P |
|---|----|---|---|---|---|---|---|
|""| 0  | 0 | 0 | 0 | 0 | 0 | 0 |
|C | 0  | 0 | 1 | 1 | 1 | 1 | 1 |
|A | 0  | 1 | 1 | 2 | 2 | 2 | 2 |
|P | 0  | 1 | 1 | 2 | 2 | 2 | 3 |

- **대각선 ↖️** : `A[i-1] === B[j-1]`  +1
- **위쪽 ↑** or **왼쪽 ←** : 공통문자 아니면 *큰 값*으로 갱신

### 4 LCS 문자열 복원 #역추적

```javascript
let i = A.length;
let j = B.length;
let lcs = [];

while (i > 0 && j > 0) {
  if (A[i - 1] === B[j - 1]) {
    lcs.unshift(A[i - 1]);
    i--; j--;
  } else if (dp[i - 1][j] > dp[i][j - 1]) {
    i--;
  } else {
    j--;
  }
}
```

- `unshift()`로 앞에 삽입 → 문자열을 순서대로 복원 가능    
- **위쪽, 왼쪽, 대각선** 방향을 따라가며 복원

## 📌 바텀업과 탑다운 비교

| 항목       | 바텀업       | 탑다운 (메모이제이션) |
| -------- | --------- | ------------ |
| 구조       | 반복문       | 재귀 호출        |
| 성능       | 빠름        | 상대적으로 느림     |
| 스택 오버플로우 | ❌         | ⚠️ 발생 가능     |
| 조건 체크    | 단순        | 많음           |
| 메모리 사용   | DP 테이블 필요 | 비교적 적음       |

### 왜 바텀업이 *더 효과적*일까?

- **스택 호출 없음 → 안정적인 성능**
- DP 테이블을 **순서대로 채워가면**, 조건문 없이 계산 가능
- 테이블이 이미 완성되어 있으므로 역추적이 편안함

> 🤷‍♀️ 하지만 바텀업은 메모리를 훨씬 더 사용하지 않을까?

- **슬라이딩 윈도우 기법**으로 **1차원 배열만으로 구현** 가능하다.

```javascript
// 피보나치
let a = 0, b = 1;
for (let i = 2; i <= n; i++) {
  [a, b] = [b, (a + b) % MOD];
}
```

- DP 상태 전이를 **최소한으로 저장**    
- 이런 최적화 방식은 **공간복잡도 O(n) → O(1)** 가능

## 📈 공통 수열 문제 유형

| 유형           | 설명            | 점화식 예시                                            |
| ------------ | ------------- | ------------------------------------------------- |
| LCS          | 가장 긴 공통 부분 수열 | `dp[i][j] = dp[i-1][j-1]+1`<br>`max(...)`         |
| 최장 공통 부분 문자열 | 연속된 공통 문자열    | `dp[i][j] = (s1[i]==s2[j]) ? dp[i-1][j-1]+1 : 0`  |
| LIS          | 가장 긴 증가 수열    | `dp[i] = max(dp[j] + 1)` <br>`if arr[i] > arr[j]` |

##  LIS 간단 코드

```javascript
function getLIS(arr) {
  const dp = Array(arr.length).fill(1);
  for (let i = 1; i < arr.length; i++) {
    for (let j = 0; j < i; j++) {
      if (arr[i] > arr[j]) {
        dp[i] = Math.max(dp[i], dp[j] + 1);
      }
    }
  }
  return Math.max(...dp);
}

console.log(getLIS([10, 20, 10, 30, 20, 50])); // 4
```

>  정렬되지 않은 배열에서 **오름차순으로 가장 긴 부분 수열 길이**를 구한다.
>  LCS는 문자열 기반, LIS는 숫자 기반 → **사용 목적 다름**

## 🧘 깨달은 점

- 처음엔 LCS 점화식이 왜 그런지 잘 감이 안 왔지만, **2차원 테이블을 직접 손코딩해보며 흐름을 익히니 점화식이 눈에 들어왔다.**
- 역추적이 `테이블에 의존`하다보니 *바텀업*이 더 직관적으로 다가왔다.


> 수열/문자열 기반 DP 문제 틀에 조금 익숙해졌고
> LCS는 **방향성과 흐름이 굉장히 중요하다는 인식**을 받았다.

> 점화식은 어느정도 공식 같은데
> 어디서부터 어디까지 외워도 되는지 약간 걱정되는 중😮‍💨

## 🎯 내일의 목표

| 주제               |
| ---------------- |
| 슬라이딩 윈도우, 누적합 기법 |
| 그리디 개념           |

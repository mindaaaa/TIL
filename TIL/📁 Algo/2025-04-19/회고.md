`Today I Learned` 점화식 & DP 자신감 UP! 

## 📌 오늘의 키워드 #TIL

- [x] 점화식 패턴 익히기
- [x] Top-Down & Bottom-Up 구조 체득
- [x] **순서가 중요한/중요하지 않은 문제 구분**
- [x] **DP + 다른 알고리즘 혼합문제의 출발점 잡기**

## 😨 DP, 수포자에겐 너무 어려운 거 아닌가?

- 점화식이 등장한다는 말에 *수포자였던 나*는 반신반의하며 학습을 시작했다.  <br>*"내가 이해나 할 수 있을까?"* 싶었지만...

### 🙀 현실은?

> 생각보다 정형화된 **패턴**으로 해결되는 구조였고,  
> 심화문제는 오히려 **DP 단독**보다는  
> **DP + 다른 알고리즘**을 혼합한 문제에 가깝다는 걸 느꼈다.

## ✍️ 직접 손으로 써보며 감 잡기

- `계단 오르기`, `타일링`, `멀리뛰기`, `동전 문제`까지  
  기본 문제를 손코딩하면서 **패턴**을 익혔다.
- 처음엔 `Bottom-Up` 방식으로 시작하여 전체 흐름을 이해하고,  
  이후에는 `Top-Down`으로 다시 구현하며  
  **메모이제이션 재귀의 고통**도 몸소 느껴봤다 🤯

### 🙅‍♀️ 재귀만 쓰면 어떤 일이 벌어졌을까?

```javascript
function fib(n) {
  if (n <= 1) return n;
  return fib(n - 1) + fib(n - 2);
}
```
- 단순하게 구현할 수 있지만, 동일한 `fib(n)`을 **수없이 반복 호출**하게 된다.
>  → **O(2^n)** 복잡도로 인해 성능이 _터진다_ 💣

### 🙆‍♂️ 메모이제이션 도입 후

```javascript
const memo = {};

function fib(n) {
  if (n <= 1) return n;
  if (memo[n]) return memo[n];
  return (memo[n] = fib(n - 1) + fib(n - 2));
}
```
- 이미 구한 값을 저장하고, 다시 계산하지 않는다!
- 콜스택 깊이가 여전히 부담될 수는 있지만  훨씬 **성능이 개선**된다.
    
## 🤯 사고 확장의 순간

- 거스름돈 문제를 풀며 기존엔 DFS로 내려가는 흐름만 떠올렸다.

```javascript
// DFS 방식으로 동전 만들기
const pick = dfs(i, total - coins[i]); // 같은 동전 계속 사용
const skip = dfs(i + 1, total);        // 다음 동전으로 이동
```
<br>그런데...

```javascript
// 점화식 기반
dp[i] = dp[i - 1] + dp[i - 2];
```

> ❗ 이건 `정답(끝)`을 기준으로 문제를 바라보는 사고방식이다!

> → **정답을 만드는 경로**가 무엇인지 거꾸로 추적하며,  
수식을 유도한다는 사실이 너무 신기했다.

## 순서의 중요성

### 🚨 순서가 중요한 경우 (계단 오르기)

```javascript
// 계단 오르기 - 1칸, 2칸씩 올라갈 수 있음
for (let i = 2; i <= n; i++) {
  dp[i] = dp[i - 1] + dp[i - 2];
}
```
- 3칸 올라가는 방법: `[1,2]`, `[2,1]`, `[1,1,1]`
> → 서로 **다른 경로**로 간주됨
    

### 🚨 순서가 중요하지 않은 경우 (동전 문제)

```javascript
for (let coin of coins) {
  for (let i = coin; i <= target; i++) {
    dp[i] += dp[i - coin];
  }
}
```
- 동전 `{1, 2}`로 `4`를 만드는 경우   `[2,2]`, `[1,1,2]`, `[1,2,1]` …  

>순서를 고려하지 않고 **같은 구성은 한 번만 카운트**해야 하므로  
>**바깥 for문이 coin 기준**이다!

## 🎯 내일의 목표 (심화편)

> 이제는 1차원 배열을 넘어  
> **2차원 배열 기반의 점화식**을 이해하고 구현하는 것이 목표!

### 📌 학습 예정 주제

| 개념                | 내용                               |
| ----------------- | -------------------------------- |
| LCS (최장 공통 부분 수열) | 문자열 비교 기반 DP 문제                  |
| 2차원 DP 테이블 구성     | `dp[i][j]` 형태로, 상태를 2가지 이상으로 나누기 |
| 점화식으로 문자열 관계 유도   | 한 문자씩 비교하며 점화식 도출                |
| 상태 추적/결과 재구성      | LCS 경로를 추적하거나 부분 문자열 출력          |

## 🙇‍♂️ 마무리하며

- DP가 단순 암기 영역이 아닌 `패턴과 사고의 전환`이라는 걸 깨달았다
- 특히 `Top-Down`은 _재귀 감각이 필요하고_, `Bottom-Up`은 _패턴에 집중해야 한다_
    
> 점화식이 어렵게 느껴졌지만, 오늘 하루를 통해  
   **점화식을 내 손으로 직접 다룰 수 있다는 자신감**이 생겼다 💪

> 역시 손코딩을 하다보면
> **어느새 머릿속에 그려지는 순간**이 찾아오는 것 같다🔥🔥